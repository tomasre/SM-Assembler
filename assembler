#!/bin/bash

# assembler takes in a file which has the assembly language instructions
# for the simple machine, and converts them into the hex commands
# by subsituting the command into the correct opcode and the variable
# name into its line number where the variable is declared
# variable declarations are subsituted for their value in hex

# variables are declared with their value in decimal

#maps the operation to the opcode and exits with a 1 if not found
mapop () {
	case "$1" in 
		HALT) echo 0; return 0;;
		LOAD) echo 1; return 0;;
		STORE) echo 2; return 0;;
		ADDC) echo 3; return 0;;
		MVAC) echo 4; return 0;;
		JEQ) echo 5; return 0;;
		JLT) echo 6; return 0;;
		JMP) echo 7; return 0;;
		ADD) echo 8; return 0;;
		SUB) echo 9; return 0;;
		DEC) echo A; return 0;;
		LA) echo B; return 0;;
		LIA) echo C; return 0;;
	esac
	return 1
}

# vardecs variable MUST be set prior with a 'variablename=value linenumber' 
# on each line
# takes in 1 argument, the name of the variable, and outputs its line number
# as a 3 bit hex value (not beginning with 0x)
hexlinenum () {
	# OUTPUTS IT IN 12 BITS (3 DIGITS)
	#$1 === var name
	#echo hexlinenum called >&2
	#echo hexlinenum arg = $1 >&2
	local varline=
	while read varline; do
		local varname=$(echo $varline | sed s/=.*//)
		echo finding variable line:\'$varname\' >&2
		if [ "$1" = "$varname" ]; then
			#local numdec=$(echo $varline | sed -e s/#.*// -e s/[^=]*=//)
			local numdec=$(echo $varline | sed -e s/#.*// -e s/[^\ ]*\ //)
			#echo $numdec >&2
			local numhex=$(printf '%x' $numdec)
			#echo $numhex >&2 
			numhex=$(padtonumbits $numhex 3)
			echo $numhex
			return 0
		fi 
	done <<< "$vardecs"
	return 1
}

# takes in the number and the number of bits you want the number to fill
# example: padtonumbits 5A 4 --> outputs 005A
padtonumbits () {
	local val=$1
	while [ ${#val} -lt "$2" ]; do 
		val=0$val
	done
	echo $val
}

# extraction functions
extractop () {
	echo "$1" | sed s/[[:space:]#].*//
}

#todo
# remove all lines without a variable declaration or a operation

# set nl variable to help with new lines in variables
nl=$'\n'
# vardecs will have a 'variablename=value linenumber' on each line
# for every variable declaration in the file
vardecs=
# to keep track of the line the variable is on
linecount=1
# populate the vardecs variable
while read line || [ -n "$line" ] ; do 
	#echo $line
	opstring=$(extractop "$line")
	#echo $opstring
	opcode=$(mapop "$opstring")
	if [ "$?" -ne 0 ]; then
		#not an operator, must be variable declaration (for now)
		sanitizedline=$(echo $line | sed s~[#[:space:]].*~~)
		vardecs="$vardecs$sanitizedline $linecount$nl"
	fi
	linecount=$((linecount + 1))
done < $1
echo -e "$vardecs"

outfile=out.ml
#for nowww
rm $outfile

#go through and make subsitutions
while read line || [ -n "$line" ] ; do
	opstring=$(echo "$line" | sed s/[[:space:]#].*// )
	opcode=$(mapop "$opstring")
	if [ "$?" -ne 0 ]; then
		# variable declaration line
		varvalue=$(echo $line | sed -e s/[^=]*=// -e s/[[:space:]#].*//)
		varvalue=$(printf '%x' $varvalue)
		varvalue=$(padtonumbits $varvalue 4)
		echo 0x$varvalue >> $outfile
	else
		# operation line --> two options: op var OR op
		nameofvar=$(echo $line | sed -e s/#.*// -e s/[^\ ]*[[:space:]]//)
		hexrep=$(hexlinenum $nameofvar)
		echo "0x$opcode$hexrep" >> $outfile
	fi
done < $1
