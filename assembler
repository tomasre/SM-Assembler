#!/bin/bash

# assembler takes in a file which has the assembly language instructions
# for the simple machine, and converts them into the hex commands
# by subsituting the command into the correct opcode and the variable
# name into its line number where the variable is declared
# variable declarations are subsituted for their value in hex

# variables are declared with their value in decimal

#maps the operation to the opcode and exits with a 1 if not found
mapop () {
	case "$1" in 
		HALT) echo 0; return 0;;
		LOAD) echo 1; return 0;;
		STORE) echo 2; return 0;;
		ADDC) echo 3; return 0;;
		MVAC) echo 4; return 0;;
		JEQ) echo 5; return 0;;
		JLT) echo 6; return 0;;
		JMP) echo 7; return 0;;
		ADD) echo 8; return 0;;
		SUB) echo 9; return 0;;
		DEC) echo A; return 0;;
		LA) echo B; return 0;;
		LIA) echo C; return 0;;
	esac
	return 1
}

isvardec () {
	echo "$1" | grep -E -q "^[[:alnum:]]+=[0-9]+"
}

isopdec () {
	echo "$1" | grep -E -q "^[A-Z]{2,4}"
}

# vardecs variable MUST be set prior with a 'variablename=value linenumber' 
# on each line
# takes in 1 argument, the name of the variable, and outputs its line number
# as a 3 bit hex value (not beginning with 0x)
hexlinenum () {
	# OUTPUTS IT IN 12 BITS (3 DIGITS)
	#$1 === var name
	#echo hexlinenum called >&2
	#echo hexlinenum arg = $1 >&2
	local varline=
	while read varline; do
		local varname=$(echo $varline | sed s/=.*//)
		#echo finding variable line:\'$varname\' >&2
		if [ "$1" = "$varname" ]; then
			#local numdec=$(echo $varline | sed -e s/#.*// -e s/[^=]*=//)
			local numdec=$(echo $varline | sed -e s/#.*// -e s/[^\ ]*\ //)
			#echo $numdec >&2
			local numhex=$(printf '%x' $numdec)
			#echo $numhex >&2 
			numhex=$(padtonumbits $numhex 3)
			echo $numhex
			return 0
		fi 
	done <<< "$vardecs"
	return 1
}

# takes in the number and the number of bits you want the number to fill
# example: padtonumbits 5A 4 --> outputs 005A
padtonumbits () {
	local val=$1
	while [ ${#val} -lt "$2" ]; do 
		val=0$val
	done
	echo $val
}

# extraction functions
extractop () {
	echo "$1" | sed s/[[:space:]#].*//
}

#todo
# remove all lines without a variable declaration or a operation

# set nl variable to help with new lines in variables
nl=$'\n'
# vardecs will have a 'variablename=value linenumber' on each line
# for every variable declaration in the file
vardecs=
# to keep track of the line the variable is on
linecount=0 # incremented before
# populate the vardecs variable
while read line || [ -n "$line" ] ; do 
	linecount=$((linecount + 1))
	isopdec "$line" && continue
	isvardec || continue #must be a blank line or garbage
	
	sanitizedline=$(echo $line | sed s~[#[:space:]].*~~)
	vardecs="$vardecs$sanitizedline $linecount$nl"
done < $1

outfile=out.ml
#for nowww
rm $outfile

#go through and make subsitutions
while read line || [ -n "$line" ] ; do
	if isopdec "$line" ; then
		# operation line --> two options: op var OR op
		opstring=$(extractop "$line")
		opcode=$(mapop "$opstring")
		unaryop=false
		for unaryops in 0 3 4 A ; do
			[ unaryops = "$opcode" ] && unaryop=true && break
		done
		if [ unaryop = 'false' ] ; then
			nameofvar=$(echo $line | sed -e s/#.*// -e s/[^\ ]*[[:space:]]//)
			hexrep=$(hexlinenum $nameofvar)
			echo "0x$opcode$hexrep # $line" >> $outfile
		else
			echo "0x${opcode}000 # $line" >> $outfile
		fi
		
	elif isvardec "$line" ;then
		# variable declaration line
		varvalue=$(echo $line | sed -e s/[^=]*=// -e s/[[:space:]#].*//)
		varvalue=$(printf '%x' $varvalue)
		varvalue=$(padtonumbits $varvalue 4)
		echo 0x$varvalue \# $line >> $outfile
	fi
done < $1
